<?php
/**
 * PythonExecutor - Helper class for calling Python scripts
 * Reusable across all API endpoints
 */

class PythonExecutor {
    private $python_bin;
    private $script_dir;
    private $timeout = 60; // seconds

    public function __construct() {
        $this->python_bin = '/var/www/html/pyethone/pye_venv/bin/python';
        $this->script_dir = '/var/www/html/pyethone/scripts/bet2/python_api';
    }

    /**
     * Execute a Python script with arguments
     * 
     * @param string $script_name Name of Python script (e.g., 'get_teams.py')
     * @param array $args Arguments to pass to script
     * @return array Result from Python script
     * @throws Exception on error
     */
    public function execute($script_name, $args = []) {
        // Validate script exists
        $script_path = $this->script_dir . '/' . $script_name;
        if (!file_exists($script_path)) {
            throw new Exception("Python script not found: $script_name");
        }

        // Build command
        $command = escapeshellcmd($this->python_bin . ' ' . $script_path);

        // Add arguments
        foreach ($args as $arg) {
            $command .= ' ' . escapeshellarg($arg);
        }

        // Execute with timeout
        $command .= ' 2>&1';
        $output = $this->executeWithTimeout($command, $this->timeout);

        if ($output === null || $output === false) {
            throw new Exception('Failed to execute Python script');
        }

        // Decode JSON
        $result = json_decode($output, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('Invalid JSON from Python: ' . $output);
        }

        return $result;
    }

    /**
     * Execute command with timeout
     */
    private function executeWithTimeout($command, $timeout) {
        // Use proc_open for better control
        $descriptors = [
            0 => ['pipe', 'r'],  // stdin
            1 => ['pipe', 'w'],  // stdout
            2 => ['pipe', 'w']   // stderr
        ];

        $process = proc_open($command, $descriptors, $pipes);

        if (!is_resource($process)) {
            return false;
        }

        // Close stdin
        fclose($pipes[0]);

        // Set non-blocking mode
        stream_set_blocking($pipes[1], false);
        stream_set_blocking($pipes[2], false);

        // Read output with timeout
        $output = '';
        $error = '';
        $start = time();

        while (time() - $start < $timeout) {
            $output .= stream_get_contents($pipes[1]);
            $error .= stream_get_contents($pipes[2]);

            $status = proc_get_status($process);
            if (!$status['running']) {
                break;
            }

            usleep(100000); // 0.1 second
        }

        // Cleanup
        fclose($pipes[1]);
        fclose($pipes[2]);

        // Check if timeout
        $status = proc_get_status($process);
        if ($status['running']) {
            proc_terminate($process);
            throw new Exception('Python script timeout after ' . $timeout . ' seconds');
        }

        proc_close($process);

        // Check for errors
        if (!empty($error) && empty($output)) {
            throw new Exception('Python error: ' . $error);
        }

        return $output;
    }

    /**
     * Set timeout for Python execution
     */
    public function setTimeout($seconds) {
        $this->timeout = $seconds;
        return $this;
    }
}
?>